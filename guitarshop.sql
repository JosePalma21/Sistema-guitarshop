/* ==============================================================
   LIMPIEZA SEGURA
   ============================================================== */
DROP TABLE IF EXISTS PRODUCTO_VENTA CASCADE;
DROP TABLE IF EXISTS PRODUCTO_COMPRA CASCADE;
DROP TABLE IF EXISTS DETALLE_FACTURA CASCADE;
DROP TABLE IF EXISTS KARDEX CASCADE;
DROP TABLE IF EXISTS CREDITO CASCADE;
DROP TABLE IF EXISTS CUOTA CASCADE;
DROP TABLE IF EXISTS COMPRA CASCADE;
DROP TABLE IF EXISTS FACTURA CASCADE;
DROP TABLE IF EXISTS VENTAS CASCADE;
DROP TABLE IF EXISTS PRODUCTO CASCADE;
DROP TABLE IF EXISTS PROVEEDOR CASCADE;
DROP TABLE IF EXISTS USUARIO CASCADE;
DROP TABLE IF EXISTS CLIENTE CASCADE;

/* ==============================================================
   TABLAS BASE  (con restricciones)
   ============================================================== */

CREATE TABLE USUARIO (
  ID_USUARIO         INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  NOMBRE             VARCHAR(60)  NOT NULL,
  CORREO             VARCHAR(60)  NOT NULL UNIQUE CHECK (CORREO ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
  TELEFONO           VARCHAR(20)  NOT NULL,
  DIRECCION          VARCHAR(100) NOT NULL,
  CEDULA             VARCHAR(15)  NOT NULL UNIQUE CHECK (CEDULA ~ '^[0-9]{10}$'),
  CONTRASENA         VARCHAR(100) NOT NULL,
  FECHA              TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  FECHA_CREACION     TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT          NOT NULL,
  ID_USUARIO_MODIFI  INT          NULL
);

CREATE TABLE PROVEEDOR (
  ID_PROVEEDOR       INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  NOMBRE_PROVEEDOR   VARCHAR(100) NOT NULL,
  TELEFONO           VARCHAR(20)  NOT NULL,
  CORREO             VARCHAR(60)  NOT NULL UNIQUE CHECK (CORREO ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
  DIRECCION          VARCHAR(100) NOT NULL,
  FECHA              TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  FECHA_CREACION     TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT          NOT NULL,
  ID_USUARIO_MODIFI  INT          NULL
);

CREATE TABLE PRODUCTO (
  ID_PRODUCTO        INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  ID_PROVEEDOR       INT          NOT NULL,
  NOMBRE_PRODUCTO    VARCHAR(100) NOT NULL,
  DESCRIPCION        VARCHAR(255),
  PRECIO             NUMERIC(12,2) NOT NULL CHECK (PRECIO >= 0),
  CANTIDAD_STOCK     INT           NOT NULL CHECK (CANTIDAD_STOCK >= 0),
  FOTO               VARCHAR(254),
  FECHA              TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  FECHA_CREACION     TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT           NOT NULL,
  ID_USUARIO_MODIFI  INT           NULL,
  CONSTRAINT FK_PRODUCTO_PROVEEDOR FOREIGN KEY (ID_PROVEEDOR)
    REFERENCES PROVEEDOR(ID_PROVEEDOR) ON DELETE RESTRICT ON UPDATE RESTRICT
);

CREATE TABLE CLIENTE (
  ID_CLIENTE         INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  NOMBRE             VARCHAR(60)  NOT NULL,
  CEDULA             VARCHAR(15)  NOT NULL UNIQUE CHECK (CEDULA ~ '^[0-9]{10}$'),
  CORREO             VARCHAR(60)  NOT NULL UNIQUE CHECK (CORREO ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
  TELEFONO           VARCHAR(20)  NOT NULL,
  DIRECCION          VARCHAR(100) NOT NULL,
  FECHA              TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  FECHA_CREACION     TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT          NOT NULL,
  ID_USUARIO_MODIFI  INT          NULL
);

CREATE TABLE FACTURA (
  ID_FACTURA         INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  ID_CLIENTE         INT          NULL,
  ID_USUARIO         INT          NOT NULL,
  FECHA              TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  TOTAL_FACTURA      NUMERIC(12,2) NOT NULL DEFAULT 0 CHECK (TOTAL_FACTURA >= 0),
  FECHA_CREACION     TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT          NOT NULL,
  ID_USUARIO_MODIFI  INT          NULL,
  CONSTRAINT FK_FACTURA_USUARIO FOREIGN KEY (ID_USUARIO)
    REFERENCES USUARIO(ID_USUARIO) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT FK_FACTURA_CLIENTE FOREIGN KEY (ID_CLIENTE)
    REFERENCES CLIENTE(ID_CLIENTE) ON DELETE SET NULL ON UPDATE RESTRICT
);

CREATE TABLE COMPRA (
  ID_COMPRA          INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  ID_PROVEEDOR       INT          NOT NULL,
  ID_USUARIO         INT          NOT NULL,
  FECHA              TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  TOTAL_COMPRA       NUMERIC(12,2) NOT NULL DEFAULT 0 CHECK (TOTAL_COMPRA >= 0),
  FECHA_CREACION     TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT          NOT NULL,
  ID_USUARIO_MODIFI  INT          NULL,
  CONSTRAINT FK_COMPRA_PROVEEDOR FOREIGN KEY (ID_PROVEEDOR)
    REFERENCES PROVEEDOR(ID_PROVEEDOR) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT FK_COMPRA_USUARIO FOREIGN KEY (ID_USUARIO)
    REFERENCES USUARIO(ID_USUARIO) ON DELETE RESTRICT ON UPDATE RESTRICT
);

CREATE TABLE CUOTA (
  ID_CUOTA           VARCHAR(10)  PRIMARY KEY,
  NUM_CUOTA          VARCHAR(10)  NOT NULL,
  FECHA              DATE         NOT NULL,
  FECHA_CREACION     TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT          NOT NULL,
  ID_USUARIO_MODIFI  INT          NULL
);

CREATE TABLE CREDITO (
  ID_CREDITO         INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  ID_FACTURA         INT          NOT NULL,
  ID_CUOTA           VARCHAR(10)  NOT NULL,
  ID_CLIENTE         INT          NOT NULL,
  DEUDA              NUMERIC(12,2) NOT NULL CHECK (DEUDA >= 0),
  FECHA              TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  FECHA_CREACION     TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT           NOT NULL,
  ID_USUARIO_MODIFI  INT           NULL,
  CONSTRAINT FK_CREDITO_FACTURA FOREIGN KEY (ID_FACTURA)
    REFERENCES FACTURA(ID_FACTURA) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT FK_CREDITO_CUOTA FOREIGN KEY (ID_CUOTA)
    REFERENCES CUOTA(ID_CUOTA) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT FK_CREDITO_CLIENTE FOREIGN KEY (ID_CLIENTE)
    REFERENCES CLIENTE(ID_CLIENTE) ON DELETE RESTRICT ON UPDATE RESTRICT
);

CREATE TABLE VENTAS (
  ID_VENTA           INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  PRODUCTO_VENDIDO   VARCHAR(100) NOT NULL,
  CANTIDAD_VENDIDA   INT          NOT NULL CHECK (CANTIDAD_VENDIDA > 0),
  FECHA              TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  FECHA_CREACION     TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT          NOT NULL,
  ID_USUARIO_MODIFI  INT          NULL
);


CREATE TABLE DETALLE_FACTURA (
  ID_DET_FACT        INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  ID_PRODUCTO        INT          NOT NULL,
  ID_FACTURA         INT          NOT NULL,
  CANT_PRODUCTO      INT          NOT NULL CHECK (CANT_PRODUCTO > 0),
  PRECIO_UNITARIO    NUMERIC(12,2) NOT NULL CHECK (PRECIO_UNITARIO >= 0),
  PRECIO_TOTAL       NUMERIC(12,2) NOT NULL CHECK (PRECIO_TOTAL >= 0),
  FECHA              TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  FECHA_CREACION     TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT          NOT NULL,
  ID_USUARIO_MODIFI  INT          NULL,
  CONSTRAINT FK_DETALLE_PRODUCTO FOREIGN KEY (ID_PRODUCTO)
    REFERENCES PRODUCTO(ID_PRODUCTO) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT FK_DETALLE_FACTURA FOREIGN KEY (ID_FACTURA)
    REFERENCES FACTURA(ID_FACTURA) ON DELETE CASCADE ON UPDATE RESTRICT
);

/* Líneas de compra */
CREATE TABLE PRODUCTO_COMPRA (
  ID_PRODUCTO        INT NOT NULL,
  ID_COMPRA          INT NOT NULL,
  CANTIDAD_COMPRA    INT NOT NULL CHECK (CANTIDAD_COMPRA > 0),
  COSTO_UNITARIO     NUMERIC(12,2) NOT NULL CHECK (COSTO_UNITARIO >= 0),
  SUBTOTAL           NUMERIC(12,2) NOT NULL DEFAULT 0 CHECK (SUBTOTAL >= 0),
  PRIMARY KEY (ID_PRODUCTO, ID_COMPRA),
  CONSTRAINT FK_PC_PRODUCTO FOREIGN KEY (ID_PRODUCTO)
    REFERENCES PRODUCTO(ID_PRODUCTO) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT FK_PC_COMPRA FOREIGN KEY (ID_COMPRA)
    REFERENCES COMPRA(ID_COMPRA) ON DELETE CASCADE ON UPDATE RESTRICT
);

/* Relación opcional producto-ventas*/
CREATE TABLE PRODUCTO_VENTA (
  ID_PRODUCTO        INT NOT NULL,
  ID_VENTA           INT NOT NULL,
  PRIMARY KEY (ID_PRODUCTO, ID_VENTA),
  CONSTRAINT FK_PV_PRODUCTO FOREIGN KEY (ID_PRODUCTO)
    REFERENCES PRODUCTO(ID_PRODUCTO) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT FK_PV_VENTA FOREIGN KEY (ID_VENTA)
    REFERENCES VENTAS(ID_VENTA) ON DELETE CASCADE ON UPDATE RESTRICT
);

/* KARDEX: agregamos ID_FACTURA para registrar salidas por ventas reales */
CREATE TABLE KARDEX (
  ID_KARDEX          INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  ID_PRODUCTO        INT          NOT NULL,
  ID_VENTA           INT          NULL,
  ID_COMPRA          INT          NULL,
  ID_FACTURA         INT          NULL,
  TIPO_MOVIMIENTO    VARCHAR(50)  NOT NULL CHECK (TIPO_MOVIMIENTO IN ('ENTRADA','SALIDA')),
  INGRESO            NUMERIC(12,2) NOT NULL DEFAULT 0 CHECK (INGRESO >= 0),
  EGRESO             NUMERIC(12,2) NOT NULL DEFAULT 0 CHECK (EGRESO >= 0),
  COSTO_UNITARIO     NUMERIC(12,2) NOT NULL CHECK (COSTO_UNITARIO >= 0),
  COSTO_TOTAL        NUMERIC(12,2) NOT NULL CHECK (COSTO_TOTAL >= 0),
  VALOR_MOVIMIENTO   NUMERIC(12,2) NOT NULL CHECK (VALOR_MOVIMIENTO >= 0),
  FECHA              TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  FECHA_CREACION     TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  ID_ESTADO          INT           NOT NULL,
  ID_USUARIO_MODIFI  INT           NULL,
  CONSTRAINT FK_KX_PRODUCTO FOREIGN KEY (ID_PRODUCTO)
    REFERENCES PRODUCTO(ID_PRODUCTO) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT FK_KX_VENTA FOREIGN KEY (ID_VENTA)
    REFERENCES VENTAS(ID_VENTA) ON DELETE SET NULL ON UPDATE RESTRICT,
  CONSTRAINT FK_KX_COMPRA FOREIGN KEY (ID_COMPRA)
    REFERENCES COMPRA(ID_COMPRA) ON DELETE SET NULL ON UPDATE RESTRICT,
  CONSTRAINT FK_KX_FACTURA FOREIGN KEY (ID_FACTURA)
    REFERENCES FACTURA(ID_FACTURA) ON DELETE SET NULL ON UPDATE RESTRICT,
  /* exactamente UNA referencia */
  CONSTRAINT CK_KX_UNA_REF CHECK (
    (CASE WHEN ID_VENTA   IS NOT NULL THEN 1 ELSE 0 END) +
    (CASE WHEN ID_COMPRA  IS NOT NULL THEN 1 ELSE 0 END) +
    (CASE WHEN ID_FACTURA IS NOT NULL THEN 1 ELSE 0 END) = 1
  )
);

/* ==============================================================
   ÍNDICES para FKs (mejor desempeño)
   ============================================================== */
CREATE INDEX IF NOT EXISTS idx_producto_prov      ON PRODUCTO (ID_PROVEEDOR);
CREATE INDEX IF NOT EXISTS idx_factura_usuario    ON FACTURA (ID_USUARIO);
CREATE INDEX IF NOT EXISTS idx_factura_cliente    ON FACTURA (ID_CLIENTE);
CREATE INDEX IF NOT EXISTS idx_det_factura        ON DETALLE_FACTURA (ID_FACTURA);
CREATE INDEX IF NOT EXISTS idx_det_producto       ON DETALLE_FACTURA (ID_PRODUCTO);
CREATE INDEX IF NOT EXISTS idx_pc_compra          ON PRODUCTO_COMPRA (ID_COMPRA);
CREATE INDEX IF NOT EXISTS idx_pc_producto        ON PRODUCTO_COMPRA (ID_PRODUCTO);
CREATE INDEX IF NOT EXISTS idx_kx_prod            ON KARDEX (ID_PRODUCTO);
CREATE INDEX IF NOT EXISTS idx_kx_factura         ON KARDEX (ID_FACTURA);
CREATE INDEX IF NOT EXISTS idx_kx_compra          ON KARDEX (ID_COMPRA);

/* ==============================================================
   FUNCIONES DE NEGOCIO (PostgreSQL PL/pgSQL)
   ============================================================== */
CREATE OR REPLACE FUNCTION fn_recalc_total_factura(p_id_factura INT)
RETURNS VOID AS $$
BEGIN
  UPDATE FACTURA f
     SET TOTAL_FACTURA = COALESCE((
       SELECT SUM(PRECIO_TOTAL)
       FROM DETALLE_FACTURA df
       WHERE df.ID_FACTURA = f.ID_FACTURA
     ),0)
   WHERE f.ID_FACTURA = p_id_factura;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION fn_recalc_total_compra(p_id_compra INT)
RETURNS VOID AS $$
BEGIN
  UPDATE COMPRA c
     SET TOTAL_COMPRA = COALESCE((
       SELECT SUM(SUBTOTAL)
       FROM PRODUCTO_COMPRA pc
       WHERE pc.ID_COMPRA = c.ID_COMPRA
     ),0)
   WHERE c.ID_COMPRA = p_id_compra;
END;
$$ LANGUAGE plpgsql;

/* ==============================================================
   TRIGGERS DETALLE_FACTURA: precios, stock, kardex, total factura
   ============================================================== */

/* Completa precio_unitario si viene NULL y calcula precio_total */
CREATE OR REPLACE FUNCTION tg_df_set_prices()
RETURNS TRIGGER AS $$
DECLARE v_precio NUMERIC(12,2);
BEGIN
  IF NEW.PRECIO_UNITARIO IS NULL THEN
    SELECT PRECIO INTO v_precio FROM PRODUCTO WHERE ID_PRODUCTO = NEW.ID_PRODUCTO;
    NEW.PRECIO_UNITARIO := COALESCE(v_precio,0);
  END IF;
  NEW.PRECIO_TOTAL := NEW.CANT_PRODUCTO * NEW.PRECIO_UNITARIO;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_df_bi_prices
BEFORE INSERT ON DETALLE_FACTURA
FOR EACH ROW EXECUTE FUNCTION tg_df_set_prices();

CREATE TRIGGER trg_df_bu_prices
BEFORE UPDATE ON DETALLE_FACTURA
FOR EACH ROW EXECUTE FUNCTION tg_df_set_prices();

/* Ajusta stock y kardex tras INSERT/UPDATE/DELETE */
CREATE OR REPLACE FUNCTION tg_df_stock_kardex()
RETURNS TRIGGER AS $$
DECLARE
  v_delta INT;
  v_costo NUMERIC(12,2);
BEGIN
  IF TG_OP = 'INSERT' THEN
    v_delta := NEW.CANT_PRODUCTO;                -- salida
    v_costo := NEW.PRECIO_UNITARIO;
    UPDATE PRODUCTO
       SET CANTIDAD_STOCK = CANTIDAD_STOCK - v_delta
     WHERE ID_PRODUCTO = NEW.ID_PRODUCTO;

    IF (SELECT CANTIDAD_STOCK FROM PRODUCTO WHERE ID_PRODUCTO = NEW.ID_PRODUCTO) < 0 THEN
      RAISE EXCEPTION 'Stock negativo para producto %', NEW.ID_PRODUCTO;
    END IF;

    INSERT INTO KARDEX(ID_PRODUCTO, ID_FACTURA, TIPO_MOVIMIENTO, INGRESO, EGRESO, COSTO_UNITARIO, COSTO_TOTAL, VALOR_MOVIMIENTO)
    VALUES (NEW.ID_PRODUCTO, NEW.ID_FACTURA, 'SALIDA', 0, v_delta, v_costo, v_delta*v_costo, v_delta*v_costo);

    PERFORM fn_recalc_total_factura(NEW.ID_FACTURA);
    RETURN NEW;

  ELSIF TG_OP = 'UPDATE' THEN
    v_delta := NEW.CANT_PRODUCTO - OLD.CANT_PRODUCTO;  -- si + => más salida
    v_costo := NEW.PRECIO_UNITARIO;

    UPDATE PRODUCTO
       SET CANTIDAD_STOCK = CANTIDAD_STOCK - v_delta
     WHERE ID_PRODUCTO = NEW.ID_PRODUCTO;

    IF (SELECT CANTIDAD_STOCK FROM PRODUCTO WHERE ID_PRODUCTO = NEW.ID_PRODUCTO) < 0 THEN
      RAISE EXCEPTION 'Stock negativo para producto %', NEW.ID_PRODUCTO;
    END IF;

    /* registro kardex por la diferencia */
    IF v_delta <> 0 THEN
      INSERT INTO KARDEX(ID_PRODUCTO, ID_FACTURA, TIPO_MOVIMIENTO, INGRESO, EGRESO, COSTO_UNITARIO, COSTO_TOTAL, VALOR_MOVIMIENTO)
      VALUES (
        NEW.ID_PRODUCTO,
        NEW.ID_FACTURA,
        CASE WHEN v_delta > 0 THEN 'SALIDA' ELSE 'ENTRADA' END,
        CASE WHEN v_delta < 0 THEN ABS(v_delta) ELSE 0 END,
        CASE WHEN v_delta > 0 THEN v_delta ELSE 0 END,
        v_costo,
        ABS(v_delta)*v_costo,
        ABS(v_delta)*v_costo
      );
    END IF;

    PERFORM fn_recalc_total_factura(NEW.ID_FACTURA);
    RETURN NEW;

  ELSIF TG_OP = 'DELETE' THEN
    UPDATE PRODUCTO
       SET CANTIDAD_STOCK = CANTIDAD_STOCK + OLD.CANT_PRODUCTO
     WHERE ID_PRODUCTO = OLD.ID_PRODUCTO;

    INSERT INTO KARDEX(ID_PRODUCTO, ID_FACTURA, TIPO_MOVIMIENTO, INGRESO, EGRESO, COSTO_UNITARIO, COSTO_TOTAL, VALOR_MOVIMIENTO)
    VALUES (OLD.ID_PRODUCTO, OLD.ID_FACTURA, 'ENTRADA', OLD.CANT_PRODUCTO, 0, OLD.PRECIO_UNITARIO, OLD.CANT_PRODUCTO*OLD.PRECIO_UNITARIO, OLD.CANT_PRODUCTO*OLD.PRECIO_UNITARIO);

    PERFORM fn_recalc_total_factura(OLD.ID_FACTURA);
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_df_ai_stock
AFTER INSERT ON DETALLE_FACTURA
FOR EACH ROW EXECUTE FUNCTION tg_df_stock_kardex();

CREATE TRIGGER trg_df_au_stock
AFTER UPDATE ON DETALLE_FACTURA
FOR EACH ROW EXECUTE FUNCTION tg_df_stock_kardex();

CREATE TRIGGER trg_df_ad_stock
AFTER DELETE ON DETALLE_FACTURA
FOR EACH ROW EXECUTE FUNCTION tg_df_stock_kardex();

/* ==============================================================
   TRIGGERS PRODUCTO_COMPRA: subtotal, total compra, stock y kardex
   ============================================================== */

CREATE OR REPLACE FUNCTION tg_pc_set_subtotal()
RETURNS TRIGGER AS $$
BEGIN
  NEW.SUBTOTAL := NEW.CANTIDAD_COMPRA * NEW.COSTO_UNITARIO;
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

CREATE TRIGGER trg_pc_bi_subtotal
BEFORE INSERT ON PRODUCTO_COMPRA
FOR EACH ROW EXECUTE FUNCTION tg_pc_set_subtotal();

CREATE TRIGGER trg_pc_bu_subtotal
BEFORE UPDATE ON PRODUCTO_COMPRA
FOR EACH ROW EXECUTE FUNCTION tg_pc_set_subtotal();

CREATE OR REPLACE FUNCTION tg_pc_stock_kardex()
RETURNS TRIGGER AS $$
DECLARE v_delta INT; v_costo NUMERIC(12,2);
BEGIN
  IF TG_OP = 'INSERT' THEN
    v_delta := NEW.CANTIDAD_COMPRA; v_costo := NEW.COSTO_UNITARIO;

    UPDATE PRODUCTO
       SET CANTIDAD_STOCK = CANTIDAD_STOCK + v_delta
     WHERE ID_PRODUCTO = NEW.ID_PRODUCTO;

    INSERT INTO KARDEX(ID_PRODUCTO, ID_COMPRA, TIPO_MOVIMIENTO, INGRESO, EGRESO, COSTO_UNITARIO, COSTO_TOTAL, VALOR_MOVIMIENTO)
    VALUES (NEW.ID_PRODUCTO, NEW.ID_COMPRA, 'ENTRADA', v_delta, 0, v_costo, v_delta*v_costo, v_delta*v_costo);

    PERFORM fn_recalc_total_compra(NEW.ID_COMPRA);
    RETURN NEW;

  ELSIF TG_OP = 'UPDATE' THEN
    v_delta := NEW.CANTIDAD_COMPRA - OLD.CANTIDAD_COMPRA; v_costo := NEW.COSTO_UNITARIO;

    UPDATE PRODUCTO
       SET CANTIDAD_STOCK = CANTIDAD_STOCK + v_delta
     WHERE ID_PRODUCTO = NEW.ID_PRODUCTO;

    IF v_delta <> 0 THEN
      INSERT INTO KARDEX(ID_PRODUCTO, ID_COMPRA, TIPO_MOVIMIENTO, INGRESO, EGRESO, COSTO_UNITARIO, COSTO_TOTAL, VALOR_MOVIMIENTO)
      VALUES (
        NEW.ID_PRODUCTO, NEW.ID_COMPRA,
        CASE WHEN v_delta > 0 THEN 'ENTRADA' ELSE 'SALIDA' END,
        CASE WHEN v_delta > 0 THEN v_delta ELSE 0 END,
        CASE WHEN v_delta < 0 THEN ABS(v_delta) ELSE 0 END,
        v_costo, ABS(v_delta)*v_costo, ABS(v_delta)*v_costo
      );
    END IF;

    PERFORM fn_recalc_total_compra(NEW.ID_COMPRA);
    RETURN NEW;

  ELSIF TG_OP = 'DELETE' THEN
    UPDATE PRODUCTO
       SET CANTIDAD_STOCK = CANTIDAD_STOCK - OLD.CANTIDAD_COMPRA
     WHERE ID_PRODUCTO = OLD.ID_PRODUCTO;

    IF (SELECT CANTIDAD_STOCK FROM PRODUCTO WHERE ID_PRODUCTO = OLD.ID_PRODUCTO) < 0 THEN
      RAISE EXCEPTION 'Stock negativo al revertir compra para producto %', OLD.ID_PRODUCTO;
    END IF;

    INSERT INTO KARDEX(ID_PRODUCTO, ID_COMPRA, TIPO_MOVIMIENTO, INGRESO, EGRESO, COSTO_UNITARIO, COSTO_TOTAL, VALOR_MOVIMIENTO)
    VALUES (OLD.ID_PRODUCTO, OLD.ID_COMPRA, 'SALIDA', 0, OLD.CANTIDAD_COMPRA, OLD.COSTO_UNITARIO, OLD.CANTIDAD_COMPRA*OLD.COSTO_UNITARIO, OLD.CANTIDAD_COMPRA*OLD.COSTO_UNITARIO);

    PERFORM fn_recalc_total_compra(OLD.ID_COMPRA);
    RETURN OLD;
  END IF;
  RETURN NULL;
END; $$ LANGUAGE plpgsql;

CREATE TRIGGER trg_pc_ai_stock
AFTER INSERT ON PRODUCTO_COMPRA
FOR EACH ROW EXECUTE FUNCTION tg_pc_stock_kardex();

CREATE TRIGGER trg_pc_au_stock
AFTER UPDATE ON PRODUCTO_COMPRA
FOR EACH ROW EXECUTE FUNCTION tg_pc_stock_kardex();

CREATE TRIGGER trg_pc_ad_stock
AFTER DELETE ON PRODUCTO_COMPRA
FOR EACH ROW EXECUTE FUNCTION tg_pc_stock_kardex();

/* ==============================================================
   VISTAS ÚTILES (opcionales)
   ============================================================== */
CREATE OR REPLACE VIEW vw_stock AS
SELECT p.ID_PRODUCTO, p.NOMBRE_PRODUCTO, p.CANTIDAD_STOCK, p.PRECIO
FROM PRODUCTO p;

CREATE OR REPLACE VIEW vw_factura_detalle AS
SELECT f.ID_FACTURA, f.FECHA, c.NOMBRE AS CLIENTE, p.NOMBRE_PRODUCTO,
       d.CANT_PRODUCTO, d.PRECIO_UNITARIO, d.PRECIO_TOTAL
FROM FACTURA f
JOIN DETALLE_FACTURA d ON d.ID_FACTURA = f.ID_FACTURA
JOIN PRODUCTO p ON p.ID_PRODUCTO = d.ID_PRODUCTO
LEFT JOIN CLIENTE c ON c.ID_CLIENTE = f.ID_CLIENTE;
